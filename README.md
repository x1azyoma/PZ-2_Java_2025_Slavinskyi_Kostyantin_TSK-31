**<h2>ПЗ-2 Славінський Костянтин ЦК-31<h2>**
___
**Тема: Оператори та типи даних**
___
*Хід роботи:*
1. Повторити теоретичні відомості;
2. Виконати три завдання з таблиці 2 відповідно до свого варіанту у таблиці 1;
3. Відповісти на контрольні питання.

___

Варіант №15.

*Вирази №5, №15, №25.*
___

Код виконання завдання у папці src.

___

**Відповіді на контрольні питання**
---
***№1. В чому полягає різниця між ключовими та зарезервованими словами?***

Ключові слова – це слова, які вже мають спеціальне значення в Java та використовуються для синтаксису мови (наприклад: class, public, if, for). Їх не можна використовувати як імена змінних, методів або класів.
Зарезервовані слова – це ширше поняття: крім ключових, вони включають слова, зарезервовані на майбутнє, які ще не мають значення,

---

***№2. Які примітивні типи даних Ви знаєте? Для кожного з них наведіть приклади, коли найбільш ефективно використовувати саме цей тип (наприклад: довжина файлу, кількість зірок на небі, рахунок у футбольному матчі, маса всесвіту, заробітна платня, ...).***


| **Тип**    | **Розрядність (біт)** | **Діапазон значень**             | **Приклади ефективного використання**                |
|-------------|----------------------|---------------------------------|-----------------------------------------------------|
| **byte**    | 8                    | -128 … 127                      | Кодування зображень, економія пам’яті у великих масивах. |
| **short**   | 16                   | -32 768 … 32 767                | Дані з обмеженим діапазоном, наприклад, кількість учнів у школі. |
| **int**     | 32                   | -2 147 483 648 … 2 147 483 647  | Лічильники, розмір файлу у байтах, рахунок у грі.     |
| **long**    | 64                   | ±9×10¹⁸                         | Великі ідентифікатори, маса зірок, час у мілісекундах. |
| **float**   | 32                   | ~7 значущих цифр                | Приблизні обчислення: фізичні симуляції, графіка.    |
| **double**  | 64                   | ~15 значущих цифр               | Точні розрахунки: фінанси, наукові обчислення.       |
| **char**    | 16                   | Символи Unicode (0 … 65 535)    | Зберігання окремих символів, наприклад, 'A'.         |
| **boolean** | 1 (логічно)          | `true` або `false`              | Логічні прапорці, перевірка умов.                    |

---
***№3. Що таке знакові та беззнакові типи? До якої групи відноситься кожен з примітивних типів даних?***
Знакові типи можуть представляти як від’ємні, так і додатні значення (byte, short, int, long).

Беззнакові у класичній Java відсутні, окрім char (він беззнаковий). boolean також умовно беззнаковий.

---

***№4. Яке максимальне число можна записати у змінну типу short, char, int, long?***

Максимальні значення для примітивних цілих типів у Java:

| **Тип**    | **Максимальне значення**    |
|-------------|----------------------------|
| **short**   | 32 767                      |
| **char**    | 65 535                      |
| **int**     | 2 147 483 647               |
| **long**    | 9 223 372 036 854 775 807   |


---

***№5. Змінна типу byte може приймати значення у діапазоні -128..127. Чому цей діапазон саме такий? Чому від’ємних значень більше ніж додатних?***

byte має 8 біт. Перший біт – знак. Залишається 7 біт для значення:

Максимум: 2⁷–1 = 127.

Мінімум: -2⁷ = -128.
Від’ємних значень на одне більше, бо 0 займає одне з позитивних представлень.

---

***№6. Що таке система числення? Як переводити значення з однієї системи числення у іншу?***

Система числення – спосіб запису чисел (десяткова, двійкова, шістнадцяткова).
Переведення:

Для перетворення з десяткової у двійкову – ділимо число на 2, збираючи залишки.

Для зворотного – сумуємо добутки цифр на відповідні степені основи.
У Java є методи Integer.toBinaryString(int n) та Integer.parseInt("1010",2).

---

***№7. Що таке «Доповняльний код»?***

Це спосіб подання від’ємних чисел у двійковій системі. Отримується інверсією всіх бітів числа та додаванням 1. Використовується для зручності виконання арифметичних операцій на апаратному рівні.

---

***№8.  Пояснити результат роботи такого фрагмента коду:***

int a = 2_000_000_000;
int b = 2_000_000_000;
int c = a + b;
System.out.println(c);


*Оголошення змінних:*

a та b — це дві змінні типу int. У Java int має 32 біти та діапазон від -2 147 483 648 до 2 147 483 647.

Запис 2_000_000_000 — це звичайний синтаксис з підкресленнями для зручності читання, вони не впливають на значення.

*Додавання:*

Результат a + b дорівнює 4 000 000 000.

Це число більше, ніж максимально можливе значення для int. Тому відбувається переповнення (overflow).

*Переповнення:*

У Java переповнення для цілих типів не викликає помилки і не генерує виняток. Замість цього старші біти відкидаються, і результат обчислюється за модулем 2³².

Точний результат:

4 000 000 000 − 4 294 967 296 = −294 967 296


(бо 4 294 967 296 = 2³²).

*Вивід на екран:*

У консоль буде надруковано:

-294967296

*Висновок:*

У Java при перевищенні діапазону int відбувається циклічне переповнення без попередження, і результат стає від’ємним числом. Щоб уникнути цього, треба використовувати тип long або виконувати перевірку перед додаванням:


---


***№9. Чим тип float відрізняється від double?***

float – 32 біти, ~7 значущих цифр. Менше місця, менша точність.

double – 64 біти, ~15 значущих цифр. Рекомендовано за замовчуванням для чисел з плаваючою комою.


---


***№10. Що таке число з рухомою комою? Що таке мантиса та степінь?***

Число з рухомою комою – представлення числа як мантиси (значущі цифри) та степеня (показник 10 або 2). Наприклад, 6.02×10²³: мантиса 6.02, степінь 23. У двійковій системі Java використовує стандарт IEEE 754.

---

***№11. Що таке Double.NaN?***

NaN = «Not a Number». Використовується для позначення результатів невизначених обчислень (наприклад, 0.0/0.0).


---


***№12. Пояснити результат роботи такого фрагменту коду:
System.out.println(Double.NaN==Double.NaN);***

Виведе false. Згідно IEEE 754, NaN не дорівнює жодному значенню, навіть самому собі. Перевіряти потрібно через Double.isNaN(x).

---


***№13.Пояснити різницю між преінкрементом та постінкрементом. Навести приклади, коли ці операції призводять до різних результатів.***


Преінкремент (++x): спочатку збільшує значення, потім використовує його.

Постінкремент (x++): спочатку використовує значення, потім збільшує.
Приклад:

int x = 5;
System.out.println(++x); // 6
x = 5;
System.out.println(x++); // 5 (але тепер x=6)


---

***№14. . В чому різниця між логічною та побітовою операцією AND? Чому звичайна операція AND (&) є в обох варіантах, а її короткозамкнута версія (&&) лише тільки логічна?***

&& – логічна операція: зупиняється на першому false (коротке замикання).

& – побітова операція: порівнює кожен біт. Також може діяти як логічне AND без короткого замикання.
Короткозамкнене && існує лише для логічних виразів, бо побітові операції завжди мають обробити всі біти.


---


***№15. В чому різниця між OR та XOR?***

OR (|) – повертає 1, якщо хоча б один операнд 1.

XOR (^) – повертає 1, якщо операнди різні.
Приклад:
| A | B | A|B | A^B |
|---|---|-----|-----|
|0|0|0|0|
|0|1|1|1|
|1|0|1|1|
|1|1|1|0|


---


***№16. Проаналізувати наступний фрагмент програми. Передбачити його результат. Запустити. Пояснити.***

 boolean a = true && false | false;
 System.out.println(a = false);
        
boolean b = true && false || false;
System.out.println(b = true);



Вираз true && false → false.

false | false → false. Отже a=false.

Але у System.out.println(a = false) – це присвоєння, тому на екран виведеться false.

У другому випадку: true && false → false.

false || false → false. Отже b=false.

Потім b = true (присвоєння), і виводиться true.

*Вивід у консолі:*

false
true

---
